This FFT is a classic NRC style real value FFT.

Under optimal conditions, the FFT  has  a maximum limit of 8 million
digits.  Beyond that, the program has to use the fractal multiply to
break large chunks  into  small  enough  blocks.   (At 8m digits, it
consumes 32megs of memory.)

Depending upon the quality  of  your  trig,  and  whether you have a
'long double' FPU, the limit may be as low as 1m digits.

Although my own Quad-2 FFT has several trig options,  to  make  sure
that you can go as high as 8m, this one does not.

I don't know for sure what the limit of the 2 digit version will be.
I  suspect  it  would  be able to go to 1g digits of pi, but I can't
check, of course.  Also, if  you  use  an external FFT library, this
limit will depend upon it.  TEST it!  Use  the  testing  routine  to
check  the multiplication by giving the program a negative number of
digits to  compute:   pi  -512m  would  test  the  multiply for 512m
decimal digits.  If you need to, you can  reduce  the  MaxFFTLen  in
fft.h.

This FFT is a very simple minded FFT.  It's  a  "Numerical  Recipes"
style  FFT  (although  this  particular one was written by me and is
public domain.)  This is the FFT  that is used in my v1.2.5 tutorial
pi program.  Since they are the same FFT, it helps show the  sizable
difference  that  FFTs  (and  other  algorithms)  can  have on total
performance.

It's incredibly slow, but it makes  a good demonstration of how much
a poor/decent FFT can effect the program's performance.


